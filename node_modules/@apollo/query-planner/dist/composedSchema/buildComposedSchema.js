"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildComposedSchema = void 0;
const graphql_1 = require("graphql");
const assert_1 = require("../utilities/assert");
const graphql_2 = require("../utilities/graphql");
const MultiMap_1 = require("../utilities/MultiMap");
function buildComposedSchema(document) {
    var _a, _b;
    const schema = graphql_1.buildASTSchema(document);
    const coreName = 'core';
    const coreDirective = schema.getDirective(coreName);
    assert_1.assert(coreDirective, `Expected core schema, but can't find @core directive`);
    const coreDirectivesArgs = graphql_2.getArgumentValuesForRepeatableDirective(coreDirective, schema.astNode);
    for (const coreDirectiveArgs of coreDirectivesArgs) {
        const feature = coreDirectiveArgs['feature'];
        if (!(feature === 'https://specs.apollo.dev/core/v0.1' ||
            feature === 'https://specs.apollo.dev/join/v0.1')) {
            throw new graphql_1.GraphQLError(`Unsupported core schema feature and/or version: ${feature}`, schema.astNode);
        }
    }
    const joinName = 'join';
    function getJoinDirective(name) {
        const fullyQualifiedName = `${joinName}__${name}`;
        const directive = schema.getDirective(fullyQualifiedName);
        assert_1.assert(directive, `Composed schema should define @${fullyQualifiedName} directive`);
        return directive;
    }
    const ownerDirective = getJoinDirective('owner');
    const typeDirective = getJoinDirective('type');
    const fieldDirective = getJoinDirective('field');
    const graphDirective = getJoinDirective('graph');
    const graphEnumType = schema.getType(`${joinName}__Graph`);
    assert_1.assert(graphql_1.isEnumType(graphEnumType), `${joinName}__Graph should be an enum`);
    const graphMap = Object.create(null);
    schema.extensions = {
        ...schema.extensions,
        federation: {
            graphs: graphMap,
        },
    };
    for (const graphValue of graphEnumType.getValues()) {
        const name = graphValue.name;
        const graphDirectiveArgs = graphql_2.getArgumentValuesForDirective(graphDirective, graphValue.astNode);
        assert_1.assert(graphDirectiveArgs, `${graphEnumType.name} value ${name} in composed schema should have a @${graphDirective.name} directive`);
        const graphName = graphDirectiveArgs['name'];
        const url = graphDirectiveArgs['url'];
        graphMap[name] = {
            name: graphName,
            url,
        };
    }
    for (const type of Object.values(schema.getTypeMap())) {
        if (graphql_1.isIntrospectionType(type))
            continue;
        if (!graphql_1.isObjectType(type))
            continue;
        assert_1.assert(type.astNode, `GraphQL type "${type.name}" should contain AST nodes`);
        const ownerDirectiveArgs = graphql_2.getArgumentValuesForDirective(ownerDirective, type.astNode);
        const typeMetadata = ownerDirectiveArgs
            ? {
                graphName: graphMap[ownerDirectiveArgs === null || ownerDirectiveArgs === void 0 ? void 0 : ownerDirectiveArgs['graph']].name,
                keys: new MultiMap_1.MultiMap(),
                isValueType: false,
            }
            : {
                isValueType: true,
            };
        type.extensions = {
            ...type.extensions,
            federation: typeMetadata,
        };
        const typeDirectivesArgs = graphql_2.getArgumentValuesForRepeatableDirective(typeDirective, type.astNode);
        assert_1.assert(!(typeMetadata.isValueType && typeDirectivesArgs.length >= 1), `GraphQL type "${type.name}" cannot have a @${typeDirective.name} \
directive without an @${ownerDirective.name} directive`);
        for (const typeDirectiveArgs of typeDirectivesArgs) {
            const graphName = graphMap[typeDirectiveArgs['graph']].name;
            const keyFields = parseFieldSet(typeDirectiveArgs['key']);
            (_a = typeMetadata.keys) === null || _a === void 0 ? void 0 : _a.add(graphName, keyFields);
        }
        for (const fieldDef of Object.values(type.getFields())) {
            assert_1.assert(fieldDef.astNode, `Field "${type.name}.${fieldDef.name}" should contain AST nodes`);
            const fieldDirectiveArgs = graphql_2.getArgumentValuesForDirective(fieldDirective, fieldDef.astNode);
            if (!fieldDirectiveArgs)
                continue;
            const fieldMetadata = {
                graphName: (_b = graphMap[fieldDirectiveArgs === null || fieldDirectiveArgs === void 0 ? void 0 : fieldDirectiveArgs['graph']]) === null || _b === void 0 ? void 0 : _b.name,
            };
            fieldDef.extensions = {
                ...fieldDef.extensions,
                federation: fieldMetadata,
            };
            const { requires, provides } = fieldDirectiveArgs;
            if (requires) {
                fieldMetadata.requires = parseFieldSet(requires);
            }
            if (provides) {
                fieldMetadata.provides = parseFieldSet(provides);
            }
        }
    }
    const schemaConfig = schema.toConfig();
    return new graphql_1.GraphQLSchema({
        ...schemaConfig,
        types: schemaConfig.types.filter(isExported),
        directives: schemaConfig.directives.filter(isExported),
    });
    function isExported(element) {
        return !(isAssociatedWithFeature(element, coreName) || isAssociatedWithFeature(element, joinName));
    }
    function isAssociatedWithFeature(element, featureName) {
        return (graphql_1.isDirective(element) && element.name === featureName ||
            element.name.startsWith(`${featureName}__`));
    }
}
exports.buildComposedSchema = buildComposedSchema;
function parseFieldSet(source) {
    const selections = graphql_2.parseSelections(source);
    assert_1.assert(selections.every(graphql_2.isASTKind('Field', 'InlineFragment')), `Field sets may not contain fragment spreads, but found: "${source}"`);
    assert_1.assert(selections.length > 0, `Field sets may not be empty`);
    return selections;
}
//# sourceMappingURL=buildComposedSchema.js.map