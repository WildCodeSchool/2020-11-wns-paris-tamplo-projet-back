"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectionSetFromFieldSet = exports.groupByParentType = exports.groupByResponseName = exports.matchesField = exports.printFields = void 0;
const graphql_1 = require("graphql");
const graphql_2 = require("./utilities/graphql");
const array_1 = require("./utilities/array");
function printFields(fields) {
    if (!fields)
        return '[]';
    return ('[' +
        fields
            .map(field => `"${field.scope.parentType.name}.${field.fieldDef.name}"`)
            .join(', ') +
        ']');
}
exports.printFields = printFields;
function matchesField(field) {
    return (otherField) => {
        return field.fieldDef.name === otherField.fieldDef.name;
    };
}
exports.matchesField = matchesField;
exports.groupByResponseName = array_1.groupBy(field => graphql_2.getResponseName(field.fieldNode));
exports.groupByParentType = array_1.groupBy(field => field.scope.parentType);
function selectionSetFromFieldSet(fields, parentType) {
    return {
        kind: graphql_1.Kind.SELECTION_SET,
        selections: Array.from(exports.groupByParentType(fields)).flatMap(([typeCondition, fieldsByParentType]) => {
            const directives = fieldsByParentType[0].scope.directives;
            return wrapInInlineFragmentIfNeeded(Array.from(exports.groupByResponseName(fieldsByParentType).values()).map((fieldsByResponseName) => {
                return combineFields(fieldsByResponseName).fieldNode;
            }), typeCondition, parentType, directives);
        }),
    };
}
exports.selectionSetFromFieldSet = selectionSetFromFieldSet;
function wrapInInlineFragmentIfNeeded(selections, typeCondition, parentType, directives) {
    return typeCondition === parentType
        ? selections
        : [
            {
                kind: graphql_1.Kind.INLINE_FRAGMENT,
                typeCondition: {
                    kind: graphql_1.Kind.NAMED_TYPE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: typeCondition.name,
                    },
                },
                selectionSet: { kind: graphql_1.Kind.SELECTION_SET, selections },
                directives
            },
        ];
}
function combineFields(fields) {
    const { scope, fieldNode, fieldDef } = fields[0];
    const returnType = graphql_1.getNamedType(fieldDef.type);
    if (graphql_1.isCompositeType(returnType)) {
        return {
            scope,
            fieldNode: {
                ...fieldNode,
                selectionSet: mergeSelectionSets(fields.map(field => field.fieldNode)),
            },
            fieldDef,
        };
    }
    else {
        return { scope, fieldNode, fieldDef };
    }
}
function mergeSelectionSets(fieldNodes) {
    const selections = [];
    for (const fieldNode of fieldNodes) {
        if (!fieldNode.selectionSet)
            continue;
        selections.push(...fieldNode.selectionSet.selections);
    }
    return {
        kind: 'SelectionSet',
        selections: mergeFieldNodeSelectionSets(selections),
    };
}
function mergeFieldNodeSelectionSets(selectionNodes) {
    const [fieldNodes, fragmentNodes] = array_1.partition(selectionNodes, (node) => node.kind === graphql_1.Kind.FIELD);
    const mergedFieldNodes = Array.from(array_1.groupBy((node) => { var _a, _b; return (_b = (_a = node.alias) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : node.name.value; })(fieldNodes).values()).map((nodesWithSameResponseName) => {
        const node = { ...nodesWithSameResponseName[0] };
        if (node.selectionSet) {
            node.selectionSet = {
                ...node.selectionSet,
                selections: mergeFieldNodeSelectionSets(nodesWithSameResponseName.flatMap((node) => { var _a; return ((_a = node.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) || []; })),
            };
        }
        return node;
    });
    return [...mergedFieldNodes, ...fragmentNodes];
}
//# sourceMappingURL=FieldSet.js.map